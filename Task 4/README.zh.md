# Task 4
中文 | [英文](README.md)

将简单的表达式转换为真正的 x86-64 汇编代码。

就像 Task 3 中一样：

> 需要转化的 C 代码（*原函数*）是：
>
> 1. 一个有三个参数的函数（所有参数与变量均为 64 位有符号整数）。
> 2. 60 个局部变量（都被使用过）。
> 3. 60 个简单的赋值表达式语句，均为 `X = Y op Z` 的形式：
>     * `X` 与 `Y` 均为局部变量。
>     * `Z` 为局部变量、参数或常数。
>     * 运算符 `op` 为 `+`、`-`、`*` 或 `/`。
>
> 你需要从测试数据中读取*原函数*的代码。其参数为 `a1`、`a2` 和 `a3`，局部变量为 `v1` 到 `v60`，每一行包含一个语句，开头无空白字符，以一个 `;` 结尾。运算符与运算数直接以一个空格隔开。例如：
>
> ```c
> v1 = a1 + 100;
> v2 = v1 * 70;
> v3 = v1 / v2;
> v4 = v3 - v1;
> ```

现在我们修改这个函数，让它返回所有变量的异或和（即 `x1 ^ x2 ^ ... ^ x60`）。你需要生成*真正的* x86-64 汇编代码（而不是 C 代码）：

1. 三个参数将被通过 `rdi`、`rsi` 和 `rdx` 传递。
2. 返回值需要被通过 `rax` 传递。
3. 你必须保持以下寄存器的值在你的函数被调用的前后不变，[根据 Linux x86-64 应用程序二进制接口](http://6.s081.scripts.mit.edu/sp18/x86-64-architecture-guide.html):
    * `rbx`
    * `rsp`
    * `rbp`
    * `r12`
    * `r13`
    * `r14`
    * `r15`

你需要优化你生成的汇编代码，以减小：

* 访问数组（内存）与局部变量（寄存器）的次数。
* 使用的不同的局部变量（使用的寄存器的数量）。
* 使用的数组中不同元素的数量（使用的内存大小）。

你需要输出不含声明的 AT&T 汇编代码，例如：

```asm
movq $0, %rax
ret
```

使用 checker 检查你的输出的汇编代码的正确性：

```bash
$ cd "Task 4"
$ python3 assembly-checker /path/to/your/compiled/program/a.out
```

# 截止日期
你的 Pull Request 需要在 2019 年 10 月 28 日 23:00（中国标准时间）前被创建。
